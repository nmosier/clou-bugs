<h2 id="spectre-v4-vulnerability-variant-b">Spectre v4 Vulnerability
(Variant B)</h2>
<h3 id="location">Location</h3>
<ul>
<li>Function: <code>HASH_UPDATE</code></li>
<li>File: <a
href="https://github.com/openssl/openssl/blob/065121ff198a84106023013420dedd57ac4ff53a/include/crypto/md32_common.h#L145">include/crypto/md32_common.h:145</a></li>
</ul>
<h3 id="code-snippet">Code Snippet</h3>
<pre><code>int HASH_UPDATE(HASH_CTX *c, const void *data_, size_t len)
{
    ...
    size_t n;
    ...
    n = c-&gt;num; // &lt;&lt;&lt; speculative store bypass
    if (n != 0) {
        p = (unsigned char *)c-&gt;data;

        if (len &gt;= HASH_CBLOCK || len + n &gt;= HASH_CBLOCK) {
            memcpy(p + n, data, HASH_CBLOCK - n); // &lt;&lt;&lt; memcpy() dereferences secret-tainted pointer
            ...
        } else {
            memcpy(p + n, data, len); // &lt;&lt;&lt; memcpy() dereferences secret-tainted pointer
            ...
        }
    }
    ...
}</code></pre>
<h3 id="explanation">Explanation</h3>
<p>The struct pointer parameter <code>c</code> is stored to the stack
upon entry to the function. The subsequent load of <code>c</code> on
line 145 may read the stale value at that stack memory location via
Speculative Store Bypass (<a
href="https://cve.org/CVERecord?id=CVE-2018-3639">CVE-2018-3639</a>). If
that stale value is attacker-controlled, the struct member access
<code>c-&gt;num</code> on line 145 may read an arbitrary secret from
memory, which is subsequently stored to the stack in index
<code>n</code>. Index <code>n</code> is then used in pointer arithmetic
with <code>p</code> and then dereferenced by <code>memcpy()</code> on
lines 150 and 164, leaking the value of the secret in
<code>n</code>.</p>
<p>This vulnerability may allow an attacker to leak arbitrary data in
memory.</p>
<h3 id="suggested-fix">Suggested Fix</h3>
<p>Insert a fence right before line 145 to ensure the store of parameter
<code>c</code> cannot be bypassed. See <a href="fix.c">fix.c</a>.</p>
<pre><code>$ diff bug.c fix.c
0a1,2
&gt; #include &lt;stdatomic.h&gt;
&gt; 
5a8
&gt;     atomic_thread_fence(memory_order_acquire);</code></pre>
